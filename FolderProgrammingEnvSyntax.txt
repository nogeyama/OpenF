2015.01.12
フォルダ・プログラミング環境の定式化の試み


------------------------------------------------------------
イノベーション
------------------------------------------------------------
・タテ棒(|)をナナメ棒(/)にしたらプログラミングにイノベーションが起きる．
　・並行、条件分岐、ループ、そしてプログラミングへ．
　・フォルダGUIとの統合で直感操作。メディア操作との統合．
　・デスクトップと統合したビジュアルシェル．簡易DSLへ．


------------------------------------------------------------
目的
------------------------------------------------------------
・既存のWindowsユーザ（非プログラマ）が，簡易な処理をプログラミングし簡易に処理実行できるようにする．
　さらに，高度なプログラミングへの誘導路を作る．
・ライバル
　表計算　（並みのEUPのメディア処理版を目指す）


------------------------------------------------------------
参考
------------------------------------------------------------
http://ci.nii.ac.jp/naid/110007970470
http://ci.nii.ac.jp/naid/110009602860
http://ci.nii.ac.jp/naid/110009806550
http://hdl.handle.net/2241/121170
http://www.slis.tsukuba.ac.jp/grad/assets/files/pamphlet/2014/ebook/index.html#page=13


------------------------------------------------------------
定義
------------------------------------------------------------
Fd_n/: Folder n, 
      （実現イメージはフォルダ名）
       処理付フォルダと呼ぶ．
       基本的にFd_nの名前によってF_nが一意に対応付けられる．
       F_nからFd_nは複数の対応があってもよい．
       処理成否が戻り，成功Success，失敗Fail，非適合Notmatchの３種類がある．

F_n: Function n
    　（実現イメージはLinuxコマンド）

f_n: file n　
      （実現イメージはファイル）

e_n: environment n
       Fnが影響を及ぼす空間．　
      （実現イメージはLinuxのプロセス空間，環境変数，フォルダ内のデータファイルなど）
      これは明記しない方がわかりやすいかもしれない．

Fd/ < f: フォルダFdへのファイルfの投入
      （実現イメージは，フォルダFdへのファイルfのDrag&Drop）

(r,e_1)=Fd(e_0): 環境e_0に対してFdを適用し，結果として環境e_1を得る．
       処理成否はr．
       戻り値を気にしない場合にはe_1=Fd(e_0)と省略して書く．
       フォルダに投入・生成されたファイルを直接表現したい場合（f_0の投入に対してf_11,f_12が生成された）は
       f_11+f_12+e_1=Fd(f_0+e_0)と書く．

concurrent{A||B}: 
       AとBが並行に実行される．
       原則環境は共有されないが，現実には共有環境（デバイスなど）は共有される．


------------------------------------------------------------
連鎖
------------------------------------------------------------
意味記述：
・フォルダFd_0へのファイルf_0投入がF_0への入力となり，処理結果がファイルf_1としてフォルダFd_0内に生成される．
・処理結果f_1は下位のフォルダFd_1の入力となり，処理は連鎖する．
・Fdは，値を返さない（ファイルを生成しない）ことも可能．その場合には，連鎖は停止する．
・Fdの処理結果はファイルfとして生成され，その結果は複数ファイルであってもよい．
　（フォルダを生成することもできる）
----------
初期フォルダ状態：
Fd_1/      < f_0
  Fd_2/
    Fd_3/
----------
処理：
f_1+e_1=F_1(f_0);
f_2+e_2=F_2(f_1);
f_3+e_3=F_3(f_2);
----------
最終フォルダ状態：
Fd_1/
  Fd_2/
    Fd_3/
      f_3


------------------------------------------------------------
並行
------------------------------------------------------------
意味記述：
・複数のFdが存在する場合，それらのすべてが実行される．
・その場合の実行順序は規定されない．
・入力ファイルも複製されて各処理の入力となる．
・もっとも最上位のフォルダは並行にはできない．そのようにしたい場合，
　より上位に実質的に処理を行わないフォルダであるフォルダ（pass,label,poldef等）を置くことで実現する．
----------
初期フォルダ状態：
Fd_1/      < f_0
  Fd_2a/
  Fd_2b/
  Fd_2c/
----------
処理：
f_1+e_1=F1(f_0);
concurrent{
  f_2a+e_2a=F_2a(f_1); ||
  f_2b+e_2b=F_2b(f_1); ||
  f_2c+e_2c=F_2c(f_1);
}
----------
最終フォルダ状態：
Fd_1/
  Fd_2a/
    f_2a
  Fd_2b/
    f_2b
  Fd_2c/
    f_2c


------------------------------------------------------------
else
------------------------------------------------------------
意味記述：
・並行フォルダの実行がすべて非照合だった場合には，elseフォルダ以下が実行される．
・elseフォルダしかない場合にも，else以下が実行される．
----------
初期フォルダ状態：
Fd_1/      < f_0
  Fd_2a/
  Fd_2b/
    Fd_3/
      Fd_4/
  Fd_2c/
  else/
    Fd_3e/
----------
処理：
f_1+e_1=Fd_1(f_0);
concurrent{
  (r2a,f_2a+e_2a)=F_2a(f_1); ||
  (r2b,f_2b+e_2b)=F_2b(f_1); ||
  (r2c,f_2c+e_2c)=F_2c(f_1);
}
if (NotMatch(r2a) & NotMatch(r2b) & NotMatch(r2c)) {
  else f_3+e_3=F_3e(f_1);
}
----------
最終フォルダ状態（もし，elseが動作した場合）：
Fd_1/
  Fd_2a/
  Fd_2b/
    Fd_3/
      Fd_4/
  Fd_2c/
  else/
    Fd_3e/
      f_3


------------------------------------------------------------
gather
------------------------------------------------------------
意味記述：
・gather以外の処理が最下位層まですべて終わった後，各フォルダの最下位層に生成されたファイル群を収集し，gatherへの入力として処理を継続する．
・elseはgatherの前に処理される．
----------
初期フォルダ状態：
Fd_1/      < f_0
  Fd_2a/
  Fd_2b/
    Fd_3/
      Fd_4/
  Fd_2c/
  gather/
    Fd_3g/
----------
処理：
f_1+e_1=F_1(f_0);
concurrent{
  f_2a+e_2a=F_2a(f_1);
  ||
  f_2b+e_2b=F_2b(f_1);
  f_3+e_3=F_3(f_2b);
  f_4+e_4=F_4(f_3);
  ||
  f_2c+e_2c=F_2c(f_1);
}
concurrent{
  f_3ga+e_3ga=F_3g(f_2a); ||
  f_3gb+e_3gb=F_3g(f_4);  ||
  f_3gc+e_3gc=F_3g(f_2c);
}
----------
最終フォルダ状態：
Fd_1/
  Fd_2a/
  Fd_2b/
    Fd_3/
      Fd_4/
  Fd_2c/
  gather/
    Fd_3g/
      f_3ga
      f_3gb
      f_3gc


------------------------------------------------------------
poldef NAME
------------------------------------------------------------
意味記述：
・poldef以外の処理が最下位層まですべて終わった後，各フォルダの最下位層に生成されたファイル群をpoldef直下に収集する．
・poldefフォルダにNAMEを割り当て，外部から名前での参照を可能にする．（例，call NAMEでの呼び出し）．
　これにより処理のサブルーチン（抽象化）の役割を果たす．

----------
初期フォルダ状態：
poldef NAME/      < f_0
  Fd_2a/
  Fd_2b/
    Fd_3/
      Fd_4/
  Fd_2c/
----------
処理：
f_1=F1(f_0);
concurrent{
  f_2a+e_2a=F_2a(f_1);
  ||
  f_2b+e_2b=F_2b(f_1);
  f_3+e_3=F_3(f_2b);
  f_4+e_4=F_4(f_3);
  ||
  f_2c+e_2c=F_2c(f_1);
}
----------
最終フォルダ状態：
poldef NAME/
  Fd_2a/
  Fd_2b/
    Fd_3/
      Fd_4/
  Fd_2c/
  f_2a
  f_4
  f_2c


------------------------------------------------------------
call NAME
------------------------------------------------------------
意味記述：
・NAMEで関連付けられるフォルダにファイルを導入し，その処理結果を得る．（さらに連鎖があれば処理を続ける．）
・callについては，シンタックスシュガーの候補．
----------
初期フォルダ状態：
poldef NAME/      < f_0
  Fd_2a/
  Fd_2b/
    Fd_3/
      Fd_4/
  Fd_2c/
----------
処理：
f_1=F_1(f_0);
concurrent{
  f_2a+e_2a=F_2a(f_1);
  ||
  f_2b+e_2b=F_2b(f_1);
  f_3+e_3=F_3(f_2b);
  f_4+e_4=F_4(f_3);
  ||
  f_2c+e_2c=F_2c(f_1);
}
----------
最終フォルダ状態：
poldef NAME/
  Fd_2a/
  Fd_2b/
    Fd_3/
      Fd_4/
  Fd_2c/
  f_2a
  f_4
  f_2c


------------------------------------------------------------
その他
------------------------------------------------------------
・処理付のフォルダと，通常のデータフォルダは混在しても構わない．
・フォルダ名の一部は処理のパラメータを表現する．最初に出現する空白が区切り文字．
・フォルダの処理決定は実行時．
・処理の途中でフォルダを生成することも問題ない．処理対象フォルダは実行時に決定するため，下位に生成されたフォルダは連鎖の際に処理対象となる．
・エラー処理．１つ上のフォルダに戻る．
・エラーハンドリング．try-catch的．
・作法的．confフォルダ．
・文字コード制限．
・CIFSのための文字コード変換．
・複数ファイルの一括投入＆ZIPファイル
・for-else構文
    for X
    else

    ここで，Xは，
      数値
      リスト
      入力ファイル名として，
      入力ファイル内の情報として，


----------
・例外処理
--------------------
----------
--------------------
----------
--------------------
----------
--------------------
----------
--------------------
参考にすべき：
・jQueryの工夫．
・まつもと氏のStream，配列を使う．
・DMSの構文select．
・ハードウェア用データフロー言語．
　http://ja.wikipedia.org/wiki/Verilog



2014.12.24 書き出し
2014.12.29 例追加
2014.12.30 イノベーション追加
2015.01.05 表現見直し
2015.01.12 ZIP

